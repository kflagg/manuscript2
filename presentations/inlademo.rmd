---
title: "Integrated Nested Laplace Approximations (INLA) Demonstration"
author: "Kenneth A. Flagg"
bibliography: "../references.bib"
output:
  revealjs::revealjs_presentation:
    fig_height: 6
    fig_width: 10
    fig_crop: FALSE
    height: "960px"
    width: "720px"
    theme: "black"
    slide_level: 2
    transition: "slide"
    incremental: FALSE
    self_contained: TRUE
---


```{r setup, cache = FALSE, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(cache = TRUE, echo = FALSE, warning = FALSE,
  message = FALSE, fig.width = 7, fig.height = 4, dpi = 150, out.width = '70%',
  fig.align = 'center',
  dev.args = list(family = 'sans', pointsize = 21, bg = 'transparent'))
```

```{r packages, cache = FALSE, echo = FALSE, message = FALSE, warning = FALSE}
library(spatstat)
library(INLA)
library(inlabru)
library(maptools)
```


# Motivation

## Poisson Processes and Sampling

```{r beidens}
par(mar = c(0.5, 0, 2, 0))
plot(density(bei), ribbon = FALSE, main = 'Intensity Function')
```

- Modeled as (log of) latent Gaussian Process

## Poisson Processes and Sampling

```{r beipts}
par(mar = c(0.5, 0, 2, 0))
plot(bei, pch = '.', cols = 'black', main = 'Realized Point Pattern')
```

- Observe points
- Make inferences about intensity function

## Poisson Processes and Sampling

```{r beisamp}
# Take a sample of quadrats and plot the observed point pattern.
set.seed(84323)
N_QUADS <- 10
QUAD_SIZE <- 50

w_edge <- Frame(bei)$xrange[1]
e_edge <- Frame(bei)$xrange[2]
s_edge <- Frame(bei)$yrange[1]
n_edge <- Frame(bei)$yrange[2]

botleft <- cbind(
  runif(N_QUADS, w_edge, e_edge - QUAD_SIZE),
  runif(N_QUADS, s_edge, n_edge - QUAD_SIZE)
)
bei_interior <- lapply(seq_len(nrow(botleft)), function(r){return(
    cbind(
      botleft[r, 1] + c(0, 0, QUAD_SIZE, QUAD_SIZE),
      botleft[r, 2] + c(0, QUAD_SIZE, QUAD_SIZE, 0)
    )
  )})
bei_win <- do.call(
  union.owin,
  apply(botleft, 1, function(x){return(
    owin(x[1] + c(0, QUAD_SIZE), x[2] + c(0, QUAD_SIZE))
  )})
)
bei_hole <- bei[complement.owin(bei_win, frame = Frame(bei))]
bei_samp <- bei[bei_win]
bei_window_full <- Window(bei)

par(mar = c(0.5, 0, 2, 0))
plot(bei_window_full, main = 'Observed Subset')
plot(bei_win, add = TRUE)
plot(bei_samp, pch = '.', cols = 'black', add = TRUE)
```

- Not widely done; some work on point process models for distance sampling
  data [@dspat, @yuanetal]


# INLA Introduction

## Why INLA?

- @rueetal
- Bayesian Hierarchical models
     - Many latent Gaussian variables
     - Few parameters
     - E.g. spatial prediction using Gaussian process model
- Monte Carlo methods impractical

## Why INLA?

 - Approximate posterior marginals using Laplace expansions
     - Clever algebra, end up with posterior in denominator
     - Taylor expand log-posterior about its mode
     - Results in a Gaussian approximation
     - Some numerical integration needed

## Advantages and Disadvantages

 - Advantages
    - Accurate approximation
    - Fast computation of many posterior marginals
 - Disadvantages
    - Does not provide full joint posterior
    - Slow with >4-6 parameters


<!--
## Derivations

From @rinla, Section 4.7

Include derivations of $\tilde{p}(\boldsymbol{\psi}|\mathbf{y})$, $\tilde{p}(\theta_{i}|\boldsymbol{\psi},\mathbf{y})$, and $\tilde{p}(\theta_{i}|\mathbf{y})$; and explanations of mode-finding and CCD.
-->


# Normal Example

## Normal Example

```{r ex4_8_1, eval = FALSE}
# f() specifies a Gaussian process.
formula <- y ~ x1 + x2 + f(z1, model = '...')
# Lists the names of possible models for f().
names(inla.models()$latent)
# Lists the names of possible likelihood families.
names(inla.models()$likelihood)
# Lists the names of possible priors. Default is flat?
names(inla.models()$prior)
# Example of fitting code.
inla(formula, family = '...', data)
```

```{r ex4_8_2, eval = FALSE}
lm1 <- lm(Petal.Length ~ Petal.Width, data = iris)
summary(lm1)
confint(lm1)

inla1 <- inla(Petal.Length ~ Petal.Width, family = 'gaussian', data = iris)
summary(inla1)
# 95% HPD interval.
inla.hpdmarginal(0.95, inla1$marginals.fixed$Petal.Width)

# Plot of beta_1|data.
plot(inla1$marginals.fixed$Petal.Width, type = 'l', xlab = expression(beta[1]), ylab = expression(tilde(p)(paste(beta[1], '|', y))))

# Example of posterior mean of a function of a parameter.
inla.emarginal(function(x)1/x, inla1$marginals.hyperpar$`Precision for the Gaussian observations`)
mean(1 / sample(inla1$marginals.hyperpar$`Precision for the Gaussian observations`[,'x'], size = 10000, prob = inla1$marginals.hyperpar$`Precision for the Gaussian observations`[,'y'], replace = TRUE))
```

@rinla section 4.9

- $\mathbf{y} = (y_{1}, \dots, y_{n})'$ independent Gaussian observations
- $y_{i} \sim \mathsf{N}(\theta, \sigma^{2})$
- $\theta \sim \mathsf{N}(\mu_{0}, \sigma_{0}^{2})$
- $\psi = 1/\sigma^{2}$, $\psi \sim \mathrm{Gamma}(a, b)$

The posterior distribution of the nuisance parameter is

$$p(\psi|\mathbf{y}) \propto \frac{p(\mathbf{y} | \theta, \psi) p(\theta) p(\psi)}
{p(\theta | \psi, \mathbf{y})}$$

## Normal Example

- Priors: $\mu_{0} = -3$, $\sigma_{0}^{2} = 4$, $a = 1.6$, $b = 0.4$
- 30 observed points

```{r ex4_9_0, out.width = '100%', fig.height = 4, fig.width = 10}
# Example data.
y <- c( 1.2697,  7.7637,  2.2532,  3.4557,  4.1776,  6.4320, -3.6623,  7.7567,
        5.9032,  7.2671, -2.3447,  8.0160,  3.5013,  2.8495,  0.6467,  3.2371,
        5.8573, -3.3749,  4.1507,  4.3092, 11.7327,  2.6174,  9.4942, -2.7639,
       -1.5859,  3.6986,  2.4544, -0.3294,  0.2329,  5.2846)
n <- length(y)
ybar <- mean(y)

par(mar = c(4, 1, 2, 1))
plot(x = y, y = rep(1, n), col = '#000000C0',
     main = '30 Observations', ylab = '', yaxt = 'n')
```

## Normal Example

```{r ex4_9_1, out.width = '100%', fig.height = 6, fig.width = 10}
# Hyperparameters.
mu0 <- -3
sigma2_0 <- 4
a <- 1.6
b <- 0.4

# H grid points for evaluating the posterior of psi.
H <- 101
psi.min <- 0.001
psi.max <- 0.3
psi.grid <- seq(psi.min, psi.max, length.out = H)
hprior <- dgamma(psi.grid, shape = a, rate = b)

# Compute quantities in the posterior.
theta.n <- sigma2.n <- lik <- num <- den <- prior <- numeric(H)
for(h in 1:H){
  theta.n[h] <- (psi.grid[h] * n * ybar + mu0/sigma2_0) / (psi.grid[h] * n + 1 / sigma2_0)
  sigma2.n[h] <- 1 / (n * psi.grid[h] + 1 / sigma2_0)
  prior[h] <- dnorm(theta.n[h], mu0, sd = sqrt(sigma2_0))
  lik[h] <- prod(dnorm(y, theta.n[h], sd = 1 / sqrt(psi.grid[h])))
  num[h] <- hprior[h] * prior[h] * lik[h]
  den[h] <- dnorm(theta.n[h], theta.n[h], sd = sqrt(sigma2.n[h]))
}
# Unnormalised marginal posterior for psi.
post.psi <- num / den 

# Normalise the density 
f.psi <- approxfun(psi.grid, post.psi, yleft = min(psi.grid), yright = max(psi.grid))
const <- integrate(f.psi, min(psi.grid), max(psi.grid))
post.psi <- post.psi / const$value

# Plot it.
par(mar = c(4, 1, 2, 1))
plot(psi.grid, post.psi, xlab = expression(psi), ylab = '', pch = 20, cex = 0.7, ylim = c(0, max(post.psi)), yaxt = 'n', main = expression(bold(paste('Posterior Distribution of ', psi))))
lines(psi.grid, post.psi)
```

## Normal Example

```{r ex4_9_2, out.width = '100%', fig.height = 6, fig.width = 10}
# J grid points for the evaluating the posterior for theta.
J <- 201
min.theta <- -8
max.theta <- 5
theta.grid <- seq(min.theta, max.theta, length.out = J)

# Full conditional distributions theta | psi,y 
full.cond.theta <- matrix(NA_real_, J, H)
for(j in 1:J){
  for(h in 1:H){
    full.cond.theta[j,h] <- dnorm(theta.grid[j], theta.n[h], sd = sqrt(sigma2.n[h]))
  }
}

# Plot.
par(mar = c(4, 1, 2, 1))
plot(theta.grid, full.cond.theta[,1], t = 'l', lwd = 0.7, ylab = '', xlab = expression(theta), ylim = c(0, max(full.cond.theta)), yaxt = 'n', cex = 0.7, main = expression(bold(paste('Full Conditional of ', theta, ' for Varying ', psi))))
for(h in 1:H){
  lines(theta.grid, full.cond.theta[,h], lwd = 0.7)
}
```

## Normal Example

```{r ex4_9_3, out.width = '100%', fig.height = 6, fig.width = 10}
# Weighted joint posterior for theta and psi.
Delta <- 1 / sum(post.psi)
joint.post.theta.psi <- matrix(NA_real_, J, H)
for(h in 1:H){
  joint.post.theta.psi[,h] <- full.cond.theta[,h] * post.psi[h] * Delta
}

# Plot (weighted) joint.
par(mar = c(4, 4, 2, 1))
image(theta.grid, psi.grid, joint.post.theta.psi, zlim = c(0, max(joint.post.theta.psi)), main = 'Joint Posterior', xlab = expression(theta), ylab = expression(psi))
```

## Normal Example

```{r ex4_9_4, out.width = '100%', fig.height = 6, fig.width = 10}
# Integrate out psi to obtain the marginal posterior of theta.
marg.post.theta <- rowSums(joint.post.theta.psi)

# Normalise the posterior marginal.
f.theta <- approxfun(theta.grid, marg.post.theta, yleft = min(theta.grid), yright = max(theta.grid))
const <- integrate(f.theta, min(theta.grid), max(theta.grid))
marg.post.theta <- marg.post.theta / const$value

# Plot the marginal.
rg <- c(-0.839603 , 5.836238)
par(mar = c(4, 1, 2, 1))
plot(theta.grid, marg.post.theta, t = 'l', xlab = expression(theta), ylab = '', xlim = c(rg[1], max(theta.grid)), yaxt = 'n', lty = 2, lwd = 3, main = expression(bold(paste('Posterior Distribution of ', theta)))) 
for(h in 1:H){
  lines(theta.grid, joint.post.theta.psi[,h], lwd= 0.25)
}
```

# Spatial Point Pattern: Trees in a Rainforest

## Spatial Point Pattern

```{r beiplot}
par(mar = c(0.5, 0, 2, 0))
plot(bei, pch = '.', cols = 'black', main = 'Tree Locations')
```

- _Beilschmiedia pendula Lauraceae_ locations in a plot in Panama
  [@moellerwaagepetersen]
- `bei` dataset in `spatstat` [@spatstat]


<!--
## Spatial Point Pattern
-->

```{r beiinla, eval = FALSE}
centers <- gridcenters(window(bei), 40, 20)
dx <- sum(unique(centers$x)[1:2] * c(-1, 1)) / 2
dy <- sum(unique(centers$y)[1:2] * c(-1, 1)) / 2
bei_df <- data.frame(x = centers$x, y = centers$y,
                     count = NA_integer_, area = NA_real_)

for(r in seq_len(nrow(bei_df))){
  bei_df$count[r] <- sum(bei$x >= bei_df$x[r] - dx &
                         bei$x < bei_df$x[r] + dx &
                         bei$y >= bei_df$y[r] - dy &
                         bei$y < bei_df$y[r] + dy)
  bei_df$area[r] <- area(Window(bei)[owin(c(bei_df$x[r] - dx, bei_df$x[r] + dx), c(bei_df$y[r] - dy, bei_df$y[r] + dy))])
}

par(mar = c(0.5, 0, 2, 2))
plot(im(t(matrix(bei_df$count, nrow = length(unique(bei_df$x)))), unique(bei_df$x), unique(bei_df$y), unitname = 'meters'), ncolcours = range(bei_df$counts) %*% c(-1, 1) + 1, main = 'Binned Tree Counts')
points(bei, pch = '.', col = '#00000040')
```

## Spatial Point Pattern

- Model from @moellerwaagepetersen
    - Log-intensity: $\log(\Lambda(u)) = \beta + \Psi(u)$
    - $\Psi$ a GP with exponential covariariance, variance $\sigma^{2}$, and
      practical range $\alpha$
- Priors
    - $\beta \sim \mathrm{Unif}(\infty, \infty)$
    - $\sigma \sim \mathrm{Unif}(0.001, \infty)$
    - $\log(\alpha) \sim \mathrm{Unif}(1, 235)$

```{r inlafit, eval = FALSE}
ct_matrix <- matrix(bei_df$count, nrow = length(unique(bei_df$x)))
larea_matrix <- matrix(log(bei_df$area), nrow = length(unique(bei_df$x)))
ct <- inla.matrix2vector(ct_matrix)
larea <- inla.matrix2vector(larea_matrix)
cell <- inla.matrix2vector(inla.lattice2node.mapping(nrow(ct_matrix), ncol(ct_matrix)))
bei_inla <- inla(ct ~ 1 + f(cell, model = 'matern2d', nu = 1,
                            nrow = nrow(ct_matrix), ncol = ncol(ct_matrix)),
                 offset = larea, family = 'poisson', data = bei_df)
# TODO: Specify priors (currently using default flat priors).
```

<!--
## Spatial Point Pattern
-->

```{r inlalogpred, eval = FALSE}
pred_matrix <- inla.vector2matrix(bei_inla$summary.random$cell$mean, nrow = nrow(ct_matrix), ncol = ncol(ct_matrix))

par(mar = c(0.5, 0, 2, 2))
plot(im(t(pred_matrix), unique(bei_df$x), unique(bei_df$y), unitname = 'meters'), main = 'Posterior Mean Cell Counts\n(Log Scale)')
points(bei, pch = '.', col = '#00000040')
```

## Spatial Point Pattern

```{r inlapred, eval = FALSE}
par(mar = c(0.5, 0, 2, 2))
plot(im(t(exp(pred_matrix)), unique(bei_df$x), unique(bei_df$y), unitname = 'meters'), main = 'Posterior Mean Cell Counts\n(Backtransformed)')
points(bei, pch = '.', col = '#00000040')
```

```{r beimesh}
# Parameters to experiment with.
MAX_EDGE_LENGTH <- 25
MAX_EDGE_EXT <- 50
MARGIN <- 100

# Mesh covering the site.
bei_boundary <- inla.mesh.segment(loc = do.call(cbind, vertices.owin(Window(bei))))
bei_full_mesh <- inla.mesh.create(
  boundary = bei_boundary,
  refine = list(max.edge = MAX_EDGE_LENGTH)
)
bei_full_spde <- inla.spde2.matern(mesh = bei_full_mesh)

# Mesh including a margin outside the site.
margin_mesh <- inla.mesh.2d(
  loc = bei_full_mesh$loc[,1:2], # Include nodes from site.
  offset = MARGIN,
  max.edge = MAX_EDGE_EXT # Fill in the rest with a coarser triangulation.
)
margin_spde <- inla.spde2.matern(mesh = margin_mesh)


# Meshs with coarser resolution in quadrats.
quad_hole <- do.call(
  inla.mesh.segment,
  lapply(seq_along(bei_interior), function(i){
    return(inla.mesh.segment(loc = bei_interior[[i]], grp = i - 1))
  })
)
bei_hole_mesh0 <- inla.mesh.create(
  boundary = list(bei_boundary, quad_hole),
  refine = list(max.edge = MAX_EDGE_LENGTH)
)
bei_hole0_spde <- inla.spde2.matern(mesh = bei_hole_mesh0)
bei_hole_mesh <- inla.mesh.create(
  loc = bei_hole_mesh0$loc[,1:2], # Include nodes from mesh with holes.
  boundary = bei_boundary,
  refine = list(max.edge = MAX_EDGE_EXT) # Fill in the rest with a coarser triangulation.
)
bei_hole_spde <- inla.spde2.matern(mesh = bei_hole_mesh)

# Meshs with finer resolution in quadrats.
quad_bnd <- do.call(
  inla.mesh.segment,
  lapply(seq_along(bei_interior), function(i){
    return(inla.mesh.segment(loc = apply(bei_interior[[i]], 2, rev), grp = i - 1))
  })
)
bei_samp_mesh0 <- inla.mesh.create(
  boundary = quad_bnd,
  refine = list(max.edge = MAX_EDGE_LENGTH)
)
bei_samp0_spde <- inla.spde2.matern(mesh = bei_samp_mesh0)
bei_samp_mesh <- inla.mesh.create(
  loc = bei_samp_mesh0$loc[,1:2], # Include nodes from mesh in quads.
  boundary = bei_boundary,
  refine = list(max.edge = MAX_EDGE_EXT) # Fill in the rest with a coarser triangulation.
)
bei_samp_spde <- inla.spde2.matern(mesh = bei_samp_mesh)

# Meshes with varying resolution in quadrats and a margin.
margin_hole <- inla.mesh.2d(
  loc = bei_hole_mesh$loc[,1:2], # Include nodes from mesh with holes.
  offset = MARGIN,
  max.edge = MAX_EDGE_EXT # Fill in the rest with a coarser triangulation.
)
margin_hole_spde <- inla.spde2.matern(mesh = margin_hole)
margin_samp <- inla.mesh.2d(
  loc = bei_samp_mesh$loc[,1:2], # Include nodes from quads.
  offset = MARGIN,
  max.edge = MAX_EDGE_EXT # Fill in the rest with a coarser triangulation.
)
margin_samp_spde <- inla.spde2.matern(mesh = margin_samp)
```

```{r effort}
# Identify which mesh nodes are in the oberserved region
# and create SPDE projectors for spatial mapping.
NPIX_X <- 400
NPIX_Y <- 200

obs_full <- rep(0, margin_mesh$n)
obs_full[inla.over_sp_mesh(as(Window(bei), 'SpatialPolygons'), margin_mesh, 'vertex')] <- 1
proj_margin_mesh <- inla.mesh.projector(margin_mesh, dims = c(NPIX_X, NPIX_Y))

obs_hole <- rep(0, margin_hole$n)
obs_hole[inla.over_sp_mesh(as(Window(bei_hole), 'SpatialPolygons'), margin_hole, 'vertex')] <- 1
proj_margin_hole <- inla.mesh.projector(margin_hole, dims = c(NPIX_X, NPIX_Y))

obs_samp <- rep(0, margin_samp$n)
obs_samp[inla.over_sp_mesh(as(Window(bei_samp), 'SpatialPolygons'), margin_samp, 'vertex')] <- 1
proj_margin_samp <- inla.mesh.projector(margin_samp, dims = c(NPIX_X, NPIX_Y))
```

```{r beifulllgcp, cache = TRUE}
bei_full_spdf <- as.SpatialPoints.ppp(bei)
cmp_full <- coordinates ~ mySmooth(map = coordinates, model = margin_spde) + Intercept
bei_full_lgcp <- lgcp(cmp_full, bei_full_spdf, E = obs_full, options = list(verbose = TRUE))
lambda_full <- predict(bei_full_lgcp, pixels(margin_mesh), ~ exp(mySmooth + Intercept))

plot(lambda_full, main = 'Posterior Predicted Log-Intensity', what = 'image')
plot(Window(bei), border = 'white', add = TRUE)
points(bei, pch = '.', col = 'white')
```

## Spatial Point Pattern

```{r beifulllgcpsd}
plot(lambda_full['sd'], main = 'Posterior SD of Log Intensity', what = 'image')
plot(Window(bei), border = 'white', add = TRUE)
points(bei, pch = '.', col = 'white')
```

## Spatial Point Pattern

```{r beiholelgcp, cache = TRUE}
bei_hole_spdf <- as.SpatialPoints.ppp(bei_hole)
cmp_hole <- coordinates ~ mySmooth(map = coordinates, model = margin_hole_spde) + Intercept
bei_hole_lgcp <- lgcp(cmp_hole, bei_hole_spdf, E = obs_hole, options = list(verbose = TRUE))
lambda_hole <- predict(bei_hole_lgcp, pixels(margin_hole), ~ exp(mySmooth + Intercept))

plot(lambda_hole, main = 'Posterior Predicted Log-Intensity', what = 'image')
plot(Window(bei_hole), border = 'white', add = TRUE)
points(bei_hole, pch = '.', col = 'white')
```

## Spatial Point Pattern

```{r beiholelgcpsd}
plot(lambda_hole['sd'], main = 'Posterior SD of Log-Intensity', what = 'image')
plot(Window(bei_hole), border = 'white', add = TRUE)
points(bei_hole, pch = '.', col = 'white')
```

## Spatial Point Pattern

```{r beisamplgcp, cache = TRUE}
bei_samp_spdf <- as.SpatialPoints.ppp(bei_samp)
cmp_samp <- coordinates ~ mySmooth(map = coordinates, model = margin_samp_spde) + Intercept
bei_samp_lgcp <- lgcp(cmp_samp, bei_samp_spdf, E = obs_samp, options = list(verbose = TRUE))
lambda_samp <- predict(bei_samp_lgcp, pixels(margin_samp), ~ exp(mySmooth + Intercept))

plot(lambda_samp, main = 'Posterior Predicted Log-Intensity', what = 'image')
plot(Window(bei_samp), border = 'white', add = TRUE)
plot(Window(bei), border = 'white', add = TRUE)
points(bei_samp, pch = '.', col = 'white')
```

## Spatial Point Pattern

```{r beisampllgcpsd}
plot(lambda_samp['sd'], main = 'Posterior SD of Log-Intensity', what = 'image')
plot(Window(bei_samp), border = 'white', add = TRUE)
plot(Window(bei), border = 'white', add = TRUE)
points(bei_samp, pch = '.', col = 'white')
```


# Things to Address

## Things to Address

- `inlabru` has a nice interface but is slow and poorly documented
- @simpsonetal present a faster method
- Sampling region is easy to define in R-INLA
- Evaluate performance
- Then address where to sample


# References

## References

