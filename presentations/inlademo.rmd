---
title: "Integrated Nested Laplace Approximations (INLA) Demonstration"
author: "Kenneth A. Flagg"
bibliography: "../references.bib"
output:
  revealjs::revealjs_presentation:
    fig_height: 6
    fig_width: 10
    fig_crop: FALSE
    height: "960px"
    width: "720px"
    theme: "black"
    slide_level: 2
    transition: "slide"
    incremental: FALSE
    self_contained: TRUE
---


```{r setup, cache = FALSE, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(cache = TRUE, echo = FALSE, warning = FALSE,
  message = FALSE, fig.width = 7, fig.height = 4, dpi = 150, out.width = '70%',
  fig.align = 'center',
  dev.args = list(family = 'sans', pointsize = 21, bg = 'transparent'))
```

```{r packages, cache = FALSE, echo = FALSE, message = FALSE, warning = FALSE}
set.seed(84323)
library(spatstat)
library(INLA)
library(inlabru)
library(maptools)
```


# Motivation

## Poisson Processes and Sampling

```{r beidens}
par(mar = c(0.5, 0, 2, 0))
plot(density(bei), ribbon = FALSE, main = 'Intensity Function')
```

- Modeled as (log of) latent Gaussian Process

## Poisson Processes and Sampling

```{r beipts}
par(mar = c(0.5, 0, 2, 0))
plot(bei, pch = '.', cols = 'black', main = 'Realized Point Pattern')
```

- Observe points
- Make inferences about intensity function

## Poisson Processes and Sampling

```{r beisamp}
par(mar = c(0.5, 0, 2, 0))
n_quads <- 10
botleft <- cbind(runif(n_quads, 0, 950), runif(n_quads, 0, 450))
bei_win <- do.call(
  union.owin,
  apply(botleft, 1, function(x){return(
    owin(x[1] + c(0, 50), x[2] + c(0, 50))
  )})
)
plot(Window(bei), main = 'Observed Subset')
plot(bei_win, add = TRUE)
plot(bei[bei_win], pch = '.', cols = 'black', add = TRUE)
```

- @brixmoeller one of very few examples


# INLA Introduction

## Why INLA?

- @rueetal
- Bayesian Hierarchical models
     - Many latent Gaussian variables
     - Few parameters
     - E.g. spatial prediction using Gaussian process model
- Monte Carlo methods impractical

## Why INLA?

 - Approximate posterior marginals using Laplace expansions
     - Clever algebra, end up with posterior in denominator
     - Taylor expand log-posterior about its mode
     - Results in a Gaussian approximation
     - Some numerical integration needed

## Advantages and Disadvantages

 - Advantages
    - Accurate approximation
    - Fast computation of many posterior marginals
 - Disadvantages
    - Does not provide full joint posterior
    - Slow with >4-6 parameters


<!--
## Derivations

From @rinla, Section 4.7

Include derivations of $\tilde{p}(\boldsymbol{\psi}|\mathbf{y})$, $\tilde{p}(\theta_{i}|\boldsymbol{\psi},\mathbf{y})$, and $\tilde{p}(\theta_{i}|\mathbf{y})$; and explanations of mode-finding and CCD.
-->


# Normal Example

## Normal Example

```{r ex4_8_1, eval = FALSE}
# f() specifies a Gaussian process.
formula <- y ~ x1 + x2 + f(z1, model = '...')
# Lists the names of possible models for f().
names(inla.models()$latent)
# Lists the names of possible likelihood families.
names(inla.models()$likelihood)
# Lists the names of possible priors. Default is flat?
names(inla.models()$prior)
# Example of fitting code.
inla(formula, family = '...', data)
```

```{r ex4_8_2, eval = FALSE}
lm1 <- lm(Petal.Length ~ Petal.Width, data = iris)
summary(lm1)
confint(lm1)

inla1 <- inla(Petal.Length ~ Petal.Width, family = 'gaussian', data = iris)
summary(inla1)
# 95% HPD interval.
inla.hpdmarginal(0.95, inla1$marginals.fixed$Petal.Width)

# Plot of beta_1|data.
plot(inla1$marginals.fixed$Petal.Width, type = 'l', xlab = expression(beta[1]), ylab = expression(tilde(p)(paste(beta[1], '|', y))))

# Example of posterior mean of a function of a parameter.
inla.emarginal(function(x)1/x, inla1$marginals.hyperpar$`Precision for the Gaussian observations`)
mean(1 / sample(inla1$marginals.hyperpar$`Precision for the Gaussian observations`[,'x'], size = 10000, prob = inla1$marginals.hyperpar$`Precision for the Gaussian observations`[,'y'], replace = TRUE))
```

@rinla section 4.9

- $\mathbf{y} = (y_{1}, \dots, y_{n})'$ independent Gaussian observations
- $y_{i} \sim \mathsf{N}(\theta, \sigma^{2})$
- $\theta \sim \mathsf{N}(\mu_{0}, \sigma_{0}^{2})$
- $\psi = 1/\sigma^{2}$, $\psi \sim \mathrm{Gamma}(a, b)$

The posterior distribution of the nuisance parameter is

$$p(\psi|\mathbf{y}) \propto \frac{p(\mathbf{y} | \theta, \psi) p(\theta) p(\psi)}
{p(\theta | \psi, \mathbf{y})}$$

## Normal Example

- Priors: $\mu_{0} = -3$, $\sigma_{0}^{2} = 4$, $a = 1.6$, $b = 0.4$
- 30 observed points

```{r ex4_9_0, out.width = '100%', fig.height = 4, fig.width = 10}
# Example data.
y <- c( 1.2697,  7.7637,  2.2532,  3.4557,  4.1776,  6.4320, -3.6623,  7.7567,
        5.9032,  7.2671, -2.3447,  8.0160,  3.5013,  2.8495,  0.6467,  3.2371,
        5.8573, -3.3749,  4.1507,  4.3092, 11.7327,  2.6174,  9.4942, -2.7639,
       -1.5859,  3.6986,  2.4544, -0.3294,  0.2329,  5.2846)
n <- length(y)
ybar <- mean(y)

par(mar = c(4, 1, 2, 1))
plot(x = y, y = rep(1, n), col = '#000000C0',
     main = '30 Observations', ylab = '', yaxt = 'n')
```

## Normal Example

```{r ex4_9_1, out.width = '100%', fig.height = 6, fig.width = 10}
# Hyperparameters.
mu0 <- -3
sigma2_0 <- 4
a <- 1.6
b <- 0.4

# H grid points for evaluating the posterior of psi.
H <- 101
psi.min <- 0.001
psi.max <- 0.3
psi.grid <- seq(psi.min, psi.max, length.out = H)
hprior <- dgamma(psi.grid, shape = a, rate = b)

# Compute quantities in the posterior.
theta.n <- sigma2.n <- lik <- num <- den <- prior <- numeric(H)
for(h in 1:H){
  theta.n[h] <- (psi.grid[h] * n * ybar + mu0/sigma2_0) / (psi.grid[h] * n + 1 / sigma2_0)
  sigma2.n[h] <- 1 / (n * psi.grid[h] + 1 / sigma2_0)
  prior[h] <- dnorm(theta.n[h], mu0, sd = sqrt(sigma2_0))
  lik[h] <- prod(dnorm(y, theta.n[h], sd = 1 / sqrt(psi.grid[h])))
  num[h] <- hprior[h] * prior[h] * lik[h]
  den[h] <- dnorm(theta.n[h], theta.n[h], sd = sqrt(sigma2.n[h]))
}
# Unnormalised marginal posterior for psi.
post.psi <- num / den 

# Normalise the density 
f.psi <- approxfun(psi.grid, post.psi, yleft = min(psi.grid), yright = max(psi.grid))
const <- integrate(f.psi, min(psi.grid), max(psi.grid))
post.psi <- post.psi / const$value

# Plot it.
par(mar = c(4, 1, 2, 1))
plot(psi.grid, post.psi, xlab = expression(psi), ylab = '', pch = 20, cex = 0.7, ylim = c(0, max(post.psi)), yaxt = 'n', main = expression(bold(paste('Posterior Distribution of ', psi))))
lines(psi.grid, post.psi)
```

## Normal Example

```{r ex4_9_2, out.width = '100%', fig.height = 6, fig.width = 10}
# J grid points for the evaluating the posterior for theta.
J <- 201
min.theta <- -8
max.theta <- 5
theta.grid <- seq(min.theta, max.theta, length.out = J)

# Full conditional distributions theta | psi,y 
full.cond.theta <- matrix(NA_real_, J, H)
for(j in 1:J){
  for(h in 1:H){
    full.cond.theta[j,h] <- dnorm(theta.grid[j], theta.n[h], sd = sqrt(sigma2.n[h]))
  }
}

# Plot.
par(mar = c(4, 1, 2, 1))
plot(theta.grid, full.cond.theta[,1], t = 'l', lwd = 0.7, ylab = '', xlab = expression(theta), ylim = c(0, max(full.cond.theta)), yaxt = 'n', cex = 0.7, main = expression(bold(paste('Full Conditional of ', theta, ' for Varying ', psi))))
for(h in 1:H){
  lines(theta.grid, full.cond.theta[,h], lwd = 0.7)
}
```

## Normal Example

```{r ex4_9_3, out.width = '100%', fig.height = 6, fig.width = 10}
# Weighted joint posterior for theta and psi.
Delta <- 1 / sum(post.psi)
joint.post.theta.psi <- matrix(NA_real_, J, H)
for(h in 1:H){
  joint.post.theta.psi[,h] <- full.cond.theta[,h] * post.psi[h] * Delta
}

# Plot (weighted) joint.
par(mar = c(4, 4, 2, 1))
image(theta.grid, psi.grid, joint.post.theta.psi, zlim = c(0, max(joint.post.theta.psi)), main = 'Joint Posterior', xlab = expression(theta), ylab = expression(psi))
```

## Normal Example

```{r ex4_9_4, out.width = '100%', fig.height = 6, fig.width = 10}
# Integrate out psi to obtain the marginal posterior of theta.
marg.post.theta <- rowSums(joint.post.theta.psi)

# Normalise the posterior marginal.
f.theta <- approxfun(theta.grid, marg.post.theta, yleft = min(theta.grid), yright = max(theta.grid))
const <- integrate(f.theta, min(theta.grid), max(theta.grid))
marg.post.theta <- marg.post.theta / const$value

# Plot the marginal.
rg <- c(-0.839603 , 5.836238)
par(mar = c(4, 1, 2, 1))
plot(theta.grid, marg.post.theta, t = 'l', xlab = expression(theta), ylab = '', xlim = c(rg[1], max(theta.grid)), yaxt = 'n', lty = 2, lwd = 3, main = expression(bold(paste('Posterior Distribution of ', theta)))) 
for(h in 1:H){
  lines(theta.grid, joint.post.theta.psi[,h], lwd= 0.25)
}
```

# Spatial Point Pattern: Trees in a Rainforest

## Spatial Point Pattern

```{r beiplot}
par(mar = c(0.5, 0, 2, 0))
plot(bei, pch = '.', cols = 'black', main = 'Tree Locations')
```

- _Beilschmiedia pendula Lauraceae_ locations in a plot in Panama
  [@moellerwaagepetersen]
- `bei` dataset in `spatstat` [@spatstat]


## Spatial Point Pattern

```{r beiinla}
centers <- gridcenters(window(bei), 200, 100)
dx <- sum(unique(centers$x)[1:2] * c(-1, 1)) / 2
dy <- sum(unique(centers$y)[1:2] * c(-1, 1)) / 2
bei_df <- data.frame(x = centers$x, y = centers$y,
                     count = NA_integer_, area = NA_real_)

for(r in seq_len(nrow(bei_df))){
  bei_df$count[r] <- sum(bei$x >= bei_df$x[r] - dx &
                         bei$x < bei_df$x[r] + dx &
                         bei$y >= bei_df$y[r] - dy &
                         bei$y < bei_df$y[r] + dy)
  bei_df$area[r] <- area(Window(bei)[owin(c(bei_df$x[r] - dx, bei_df$x[r] + dx), c(bei_df$y[r] - dy, bei_df$y[r] + dy))])
}

par(mar = c(0.5, 0, 2, 2))
plot(im(t(matrix(bei_df$count, nrow = length(unique(bei_df$x)))), unique(bei_df$x), unique(bei_df$y), unitname = 'meters'), ncolcours = range(bei_df$counts) %*% c(-1, 1) + 1, main = 'Binned Tree Counts')
points(bei, pch = '.', col = '#00000040')
```

## Spatial Point Pattern

- Model from @moellerwaagepetersen
    - Log-intensity: $\log(\Lambda(u)) = \beta + \Psi(u)$
    - $\Psi$ a GP with exponential covariariance, variance $\sigma^{2}$, and
      practical range $\alpha$
- Priors
    - $\beta \sim \mathrm{Unif}(\infty, \infty)$
    - $\sigma \sim \mathrm{Unif}(0.001, \infty)$
    - $\log(\alpha) \sim \mathrm{Unif}(1, 235)$

```{r inlafit, eval = FALSE}
ct_matrix <- matrix(bei_df$count, nrow = length(unique(bei_df$x)))
ct <- inla.matrix2vector(ct_matrix)
cell <- seq_along(ct)
bei_inla <- inla(ct ~ 1 + f(cell, model = 'matern2d', nu = 1,
                            nrow = nrow(ct_matrix), ncol = ncol(ct_matrix)),
                 family = 'poisson', data = bei_df)
```


```{r beilgcp}
bei_spdf <- as.SpatialPoints.ppp(bei)
# Need mesh and prior for GP.
#bei_lgcp <- lgcp(, data = bei_spdf)
```

# References

## References

