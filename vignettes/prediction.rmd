---
title: "Spatial Prediction with INLA"
author: "Kenneth A. Flagg"
bibliography: "../references.bib"
output:
  html_document:
    fig_height: 6
    fig_width: 10
    fig_crop: FALSE
    height: "960px"
    width: "720px"
    self_contained: TRUE
---


```{r setup, cache = FALSE, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(cache = FALSE, echo = TRUE, warning = FALSE,
  message = FALSE, dpi = 150, fig.align = 'center')
```

```{r packages, cache = FALSE, echo = FALSE, message = FALSE, warning = FALSE}
library(spatstat)
library(INLA)
library(inlabru)
library(maptools)
```


# SPDE Toy Example

Toy dataset from @rinla.

```{r spdetoy, fig.width = 6, out.width = '60%'}
# Plot the data.
plot(s2 ~ s1, col = rgb(SPDEtoy$y / max(SPDEtoy$y), 0, 0), data = SPDEtoy,
     pch = 19, asp = 1, main = 'Toy Data')
```

```{r spdemesh, fig.width = 6, out.width = '60%'}
# Create a mesh for the SPDE method and then plot it.
toymesh <- inla.mesh.2d(as.matrix(SPDEtoy[,c('s1', 's2')]),
                        max.edge = c(0.1, 0.2))
plot(toymesh, asp = 1)
points(SPDEtoy$s1, SPDEtoy$s2, col = rgb(SPDEtoy$y / max(SPDEtoy$y), 0, 0, 0.5),
       pch = 19)
```

```{r spdefit}
# Initialize SPDE projector matrix.
toyA <- inla.spde.make.A(toymesh, as.matrix(SPDEtoy[,c('s1', 's2')]))

# Initialize exponential covariance structure for SPDE.
toyspde <- inla.spde2.matern(toymesh, alpha = 2)

# Fit the model with INLA.
toyfit <- inla(
#  y ~ -1 + intercept + f(spatial_field, model = toyspde),
  y ~ f(spatial_field, model = toyspde),
  data = list(
    y = SPDEtoy$y,
    intercept = rep(1, nrow(SPDEtoy)),
    spatial_field = seq_len(nrow(SPDEtoy))
  )#,
#  control.predictor = list(A = toyA, compute = TRUE)
)
```


# Bei Dataset

Example from @moellerwaagepetersen, _Beilschmiedia pendula Lauraceae_ locations
in a plot in Panama. `bei` dataset in `spatstat` [@spatstat].

```{r beipts}
# Plot the full point pattern.
plot(bei, pch = '.', cols = 'black', main = 'Realized Point Pattern')
```

```{r beisamp}
# Take a sample of quadrats and plot the observed point pattern.
set.seed(84323)
n_quads <- 10
botleft <- cbind(runif(n_quads, 0, 950), runif(n_quads, 0, 450))
bei_win <- do.call(
  union.owin,
  apply(botleft, 1, function(x){return(
    owin(x[1] + c(0, 50), x[2] + c(0, 50))
  )})
)
plot(Window(bei), main = 'Observed Subset')
plot(bei_win, add = TRUE)
plot(bei[bei_win], pch = '.', cols = 'black', add = TRUE)
```

```{r beilgcp}
bei_spdf <- as.SpatialPoints.ppp(bei)
# Need mesh and prior for GP.
#bei_lgcp <- lgcp(, data = bei_spdf)
```

# References

