\documentclass{article}
\usepackage{fullpage}

\title{Example Spatial Sampling Paths}
\author{Kenny Flagg}

\begin{document}
\maketitle

<<setup, echo = FALSE, message = FALSE, warning = FALSE>>=
knitr::opts_chunk$set(echo = FALSE, fig.path = 'plans_fig/',
                      fig.height = 7, fig.width = 13)

#########################
#{{{ Setup environment. #
#########################

# Load packages.
library(spatstat)
library(lhs)
library(TSP)
library(HilbertVis)

# Define user-specified parameters.
XSECT_WIDTH <- 4 # Width of transects.
XSECT_LENGTH_MIN <- 50
XSECT_LENGTH_MAX <- 500
XSECT_LENGTH_CORR <- -0.8
XSECT_SEP_MIN <- 10
XSECT_SEP_MAX <- 250
DIST_INITIAL <- 10000
DIST_MAX <- 50000
WP_NUM_INITIAL <- 400
HILBERT_ORDER_INITIAL <- 3
NUM_PAIRS <- 3
PAIR_RADIUS <- 20 * XSECT_WIDTH
WP_MARGIN <- XSECT_WIDTH / 2 # Minimum distance between waypoints and site boundary

# Mesh parameters to experiment with.
MAX_EDGE_LENGTH <- 100
MAX_EDGE_EXT <- 200
MARGIN <- 200

# Graphics parameters.
NPIX_X <- 500
NPIX_Y <- 250


# Define derived parameters
XSECT_RADIUS <- XSECT_WIDTH / 2 # Half the transect width
XSECT_NUM_INITIAL <- floor(DIST_INITIAL / XSECT_LENGTH_MAX)


#}}}##################################
#{{{ Objects pertaining to the site. #
######################################

# Site window.

sim_R <- owin(c(0, 1500), c(0, 700))


#}}}##################################
#{{{ Objects pertaining to the data. #
######################################

# Function to simulate one realized point pattern. This includes an LGCP
# background process with Matern (alpha = 2) covariance and a foreground
# cluster process. The true intensity function is stored in an attribute
# called Lambda.
# Dots should include dimyx = c(NPIX_Y, NPIX_X).
sim_data <- function(
  R = sim_R,
  matern_mu = log(1000 / area(R)), matern_sd = 1, matern_range = 200,
  thomas_kappa = 2 / area(R), thomas_scale = 100, thomas_mu = 250,
  ...){

  # Simulate a background LGCP.
  maternlgcp <- rLGCP(
    model = 'matern',
    mu = matern_mu,
    param = list(nu = 1, var = matern_sd^2, scale = matern_range),
    win = R, saveLambda = TRUE, nsim = 1, ...
  )

  # Simulate foreground hotspots as a Thomas cluster process.
  thomas <- rThomas(
    kappa = thomas_kappa,
    scale = thomas_scale,
    mu = thomas_mu,
    win = R, saveLambda = TRUE, nsim = 1, expand = 0, ...
  )

  # Superimpose the two processes.
  result <- superimpose(maternlgcp, thomas)

  # Add the realized intensity functions.
  attr(result, 'Lambda') <- attr(maternlgcp, 'Lambda') + attr(thomas, 'Lambda')

  return(result)
}

sim_dataset <- sim_data(dimyx = c(NPIX_Y, NPIX_X))


#}}}###################################################################
#{{{ Sampling parameters applicable to all survey plans. #
##########################################################

# Function to subset a ppp to a region along a psp.
sample_ppp <- function(full_ppp, path, xsect_radius = XSECT_RADIUS){
  obs_D <- dilation(path, xsect_radius)
  obs_ppp <- full_ppp[obs_D]
  return(structure(obs_ppp, path = path))
}


#}}}#######
#{{{ SRS. #
###########

srs <- function(full_win, num_xsects = XSECT_NUM_INITIAL, xsect_radius = XSECT_RADIUS){
  full_frame <- Frame(full_win)
  min_x <- min(full_frame$x) + xsect_radius
  max_x <- max(full_frame$x) - xsect_radius
  min_y <- min(full_frame$y) - xsect_radius
  max_y <- max(full_frame$y) + xsect_radius

  srs_x <- sort(runif(num_xsects, min_x, max_x))
  waypoints <- cbind(
    x = rep(srs_x, each = 2),
    y = rep(c(min_y, max_y, max_y, min_y), ceiling(num_xsects / 2))[
      1:(2 * num_xsects)
    ]
  )
  n_waypoints <- nrow(waypoints)

  path_psp <- psp(
    x0 = waypoints[-n_waypoints, 'x'],
    y0 = waypoints[-n_waypoints, 'y'],
    x1 = waypoints[-1, 'x'],
    y1 = waypoints[-1, 'y'],
    window = dilation(full_frame, 2 * xsect_radius)
  )[full_win]
  return(path_psp)
}


#}}}############################
#{{{ Systematic random sample. #
################################

sys <- function(full_win, num_xsects = XSECT_NUM_INITIAL, xsect_radius = XSECT_RADIUS){
  full_frame <- Frame(full_win)
  min_x <- min(full_frame$x) + xsect_radius
  max_x <- max(full_frame$x) - xsect_radius
  min_y <- min(full_frame$y) - xsect_radius
  max_y <- max(full_frame$y) + xsect_radius

  spacing <- (max_x - min_x) / num_xsects
  edge2edge <- spacing - xsect_radius * 2
  sys_x <- runif(1, min_x, min_x + edge2edge) + (0:(num_xsects - 1)) * spacing
  waypoints <- cbind(
    x = rep(sys_x, each = 2),
    y = rep(c(min_y, max_y, max_y, min_y), ceiling(num_xsects / 2))[
      1:(2 * num_xsects)
    ]
  )
  n_waypoints <- nrow(waypoints)

  path_psp <- psp(
    x0 = waypoints[-n_waypoints, 'x'],
    y0 = waypoints[-n_waypoints, 'y'],
    x1 = waypoints[-1, 'x'],
    y1 = waypoints[-1, 'y'],
    window = dilation(full_frame, 2 * xsect_radius)
  )[full_win]
  return(path_psp)
}


#}}}###############################
#{{{ Inhibitory plus close pairs. #
###################################

inhib <- function(full_win, num_primary = XSECT_NUM_INITIAL - num_paired,
                  num_paired = NUM_PAIRS, pair_radius = PAIR_RADIUS,
                  antirepulsion = 0.05, xsect_radius = XSECT_RADIUS,
                  mc_iter = 1000, mc_radius = pair_radius * 2){
  full_frame <- Frame(full_win)
  min_x <- min(full_frame$x) + xsect_radius
  max_x <- max(full_frame$x) - xsect_radius
  min_y <- min(full_frame$y) - xsect_radius
  max_y <- max(full_frame$y) + xsect_radius
  num_xsects <- num_primary + num_paired

  initial_x <- runif(num_primary, min_x, max_x)

  # A simple Metropolis-Hastings algorithm.
  for(iter in seq_len(mc_iter)){
    # Count the number of current close pairs.
    current_pairs <- 0L
    for(i in 1:(num_primary - 1)){
      current_pairs <- current_pairs +
        sum(abs(initial_x[i] - initial_x[-(1:i)]) < pair_radius)
    }

    # Choose one to perturb.
    perturb_idx <- sample.int(num_primary, 1)

    # Perturb it.
    prop_x <- initial_x
    prop_x[perturb_idx] <- runif(1,
       max(prop_x[perturb_idx] - mc_radius, min_x),
       min(prop_x[perturb_idx] + mc_radius, max_x)
    )

    # Count the number of proposed close pairs.
    prop_pairs <- 0L
    for(i in 1:(num_primary - 1)){
      prop_pairs <- prop_pairs +
        sum(abs(prop_x[i] - prop_x[-(1:i)]) < pair_radius)
    }

    # Accept or reject the proposal.
    if(runif(1) < antirepulsion^(prop_pairs - current_pairs)){
      initial_x <- prop_x
    }
  }

  paired_x <- sample(initial_x, num_paired)
  pairs_x <- runif(num_paired,
                   pmax(paired_x - pair_radius, min_x),
                   pmin(paired_x + pair_radius, max_x))
  inhib_x <- sort(c(initial_x, pairs_x))
  waypoints <- cbind(
    x = rep(inhib_x, each = 2),
    y = rep(c(min_y, max_y, max_y, min_y), ceiling(num_xsects / 2))[
      1:(2 * num_xsects)
    ]
  )
  n_waypoints <- nrow(waypoints)

  path_psp <- psp(
    x0 = waypoints[-n_waypoints, 'x'],
    y0 = waypoints[-n_waypoints, 'y'],
    x1 = waypoints[-1, 'x'],
    y1 = waypoints[-1, 'y'],
    window = dilation(full_frame, 2 * xsect_radius)
  )[full_frame]
  return(path_psp)
}


#}}}#########################
#{{{ Latin traveling sales. #
#############################

lhstsp <- function(full_win, num_bins = round(sqrt(WP_NUM_INITIAL)), margin = WP_MARGIN, ...){
  full_frame <- Frame(full_win)
  min_x <- min(full_frame$x) + margin
  max_x <- max(full_frame$x) - margin
  min_y <- min(full_frame$y) + margin
  max_y <- max(full_frame$y) - margin
  sampleable <- erosion(full_win, margin)

  wp_unscaled <- maximinLHS(n = num_bins, k = 2, ...)
  wp_x <- wp_unscaled[,1] * (max_x - min_x) + min_x
  wp_y <- wp_unscaled[,2] * (max_y - min_y) + min_y
  wp_ppp <- ppp(wp_x, wp_y, window = full_frame)[sampleable]
  waypoints <- as.data.frame(wp_ppp)

  wp_tsp <- ETSP(waypoints)
  wp_tour <- waypoints[solve_TSP(wp_tsp, ...),]

  path_psp <- psp(
    x0 = wp_tour$x,
    y0 = wp_tour$y,
    x1 = c(wp_tour[-1, 'x'], wp_tour[1, 'x']),
    y1 = c(wp_tour[-1, 'y'], wp_tour[1, 'y']),
    window = full_frame
  )[full_win]
  return(path_psp)
}


#}}}#################
#{{{ Hilbert curve. #
#####################

hilbert <- function(full_win, h_order = HILBERT_ORDER_INITIAL, margin = WP_MARGIN, ...){
  full_frame <- Frame(full_win)
  min_x <- min(full_frame$x) + margin
  max_x <- max(full_frame$x) - margin
  min_y <- min(full_frame$y) + margin
  max_y <- max(full_frame$y) - margin
  sampleable <- erosion(full_win, margin)

  wp_unscaled <- hilbertCurve(h_order)
  wp_x <- (wp_unscaled[,1] + runif(1)) / (2^h_order) * (max_x - min_x) + min_x
  wp_y <- (wp_unscaled[,2] + runif(1)) / (2^h_order) * (max_y - min_y) + min_y
  wp_ppp <- ppp(wp_x, wp_y, window = full_frame)#[sampleable]
  waypoints <- as.data.frame(wp_ppp)
  n_waypoints <- nrow(waypoints)

  path_psp <- psp(
    x0 = waypoints[-n_waypoints, 'x'],
    y0 = waypoints[-n_waypoints, 'y'],
    x1 = waypoints[-1, 'x'],
    y1 = waypoints[-1, 'y'],
    window = full_frame
  )[full_win]
  return(path_psp)
}


#}}}############################
#{{{ Random particle movement. #
################################

rpm <- function(full_win, dist_cutoff = DIST_MAX, corr = XSECT_LENGTH_CORR,
                seg_min = XSECT_LENGTH_MIN, seg_max = XSECT_LENGTH_MAX,
                angle_m = pi/3, angle_s = pi/6, angle_prob = c(0.5, 0.5),
                a = 1, b = 1, pair_radius = PAIR_RADIUS, antirepulsion = 0.8,
                margin = WP_MARGIN, animate = FALSE, ...){
  full_frame <- Frame(full_win)
  min_x <- min(full_frame$x) + margin
  max_x <- max(full_frame$x) - margin
  min_y <- min(full_frame$y) + margin
  max_y <- max(full_frame$y) - margin
  sampleable <- erosion(full_win, margin)

  dist_range <- seg_max - seg_min

  pos_corr <- corr > 0
  if(!pos_corr){
    corr <- -corr
  }
  p <- corr * (a + b) / (corr + b)

  # Starting segment.
  wp <- as.data.frame(runifpoint(1, sampleable))

  reject <- TRUE
  while(reject){
    angle <- runif(1, 0, 2*pi)
    dist_unscaled <- rbeta(1, a, b)
    new_dist <- dist_unscaled * dist_range + seg_min

    new_x <- tail(wp$x, 1) + cos(angle) * new_dist
    new_y <- tail(wp$y, 1) + sin(angle) * new_dist

    if(inside.owin(new_x, new_y, sampleable)){
        reject <- FALSE
    }
  }
  path_psp <- psp(wp$x, wp$y, new_x, new_y, sim_R)
  cum_dist <- new_dist
  current_x <- tail(wp$x, 1)
  current_y <- tail(wp$y, 1)

  if(animate){
    plot(path_psp, ...)
  }

  # Loop until exceeding the distance cutoff.
  while(cum_dist < dist_cutoff){
    reject <- TRUE

    while(reject){
      new_angle <- (angle + sample(c(-1, 1), 1, prob = angle_prob) *
        rnorm(1, angle_m, angle_s)) %% (2*pi)
      new_dist_unscaled <- rbeta(1, b, a - p) *
        (1 - rbeta(1, p, a - p) * dist_unscaled)
      if(pos_corr){
        new_dist_unscaled <- 1 - new_dist_unscaled
      }

      dist_unscaled <- new_dist_unscaled
      new_dist <- dist_unscaled * dist_range + seg_min

      new_x <- current_x + cos(new_angle) * new_dist
      new_y <- current_y + sin(new_angle) * new_dist

      if(inside.owin(new_x, new_y, sampleable)){
        if(runif(1) < antirepulsion^(sum(crossdist(
            psp(current_x, current_y, new_x, new_y, sim_R),
            path_psp, type = 'separation') < pair_radius) - 1)){
          reject <- FALSE
        }
      }
    }
    angle <- new_angle
    cum_dist <- cum_dist + new_dist
    wp <- rbind(wp, data.frame(x = new_x, y = new_y))
    path_psp$ends <- rbind(path_psp$ends, data.frame(
      x0 = current_x,
      y0 = current_y,
      x1 = new_x,
      y1 = new_y
    ))
    path_psp$n <- path_psp$n + 1
    current_x <- new_x
    current_y <- new_y

    if(animate){
      plot(path_psp, add = TRUE)
    }
  }

  return(path_psp)
}


#}}}###########################

@

\section*{Full Dataset}

<<fulldata>>=
par(mar = c(0, 1, 2, 1))
plot(sim_dataset, pch = 20, main = 'Full Data')
@

The dataset is in a \(1500 \times 700\) rectangular region. It will be
surveyed such that only events within 2 units of a path are observed.

\begin{itemize}
\item Parallel transect designs
\begin{itemize}
\item Simple random sample
\item Systematic sample, evenly spaced, with random starting point
\item Inhibitory plus close pairs
\end{itemize}
\item Hilbert curve, a deterministic space-filling curve, with random starting
point
\item Shortest path (traveling salesperson) through a Latin hypercube
sampling design
\item Random particle movement, random angle and direction for each segment,
with a preference for new locations
\end{itemize}

\pagebreak


\section*{Simple Random Sample of Parallel Transects}

<<srs>>=
par(mfrow = c(2, 2), mar = c(0, 0, 1, 0), cex = 1)

srs_s1 <- srs(sim_R, 25)
plot(sim_R,
     main = paste('SRS, length =',
                  round(sum(lengths.psp(srs_s1)))))
plot(srs_s1, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, srs_s1), pch = 20, add = TRUE)

srs_l1 <- srs(sim_R, 50)
plot(sim_R,
     main = paste('SRS, length =',
                  round(sum(lengths.psp(srs_l1)))))
plot(srs_l1, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, srs_l1), pch = 20, add = TRUE)

srs_s2 <- srs(sim_R, 25)
plot(sim_R,
     main = paste('SRS, length =',
                  round(sum(lengths.psp(srs_s2)))))
plot(srs_s2, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, srs_s2), pch = 20, add = TRUE)

srs_l2 <- srs(sim_R, 50)
plot(sim_R,
     main = paste('SRS, length =',
                  round(sum(lengths.psp(srs_l2)))))
plot(srs_l2, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, srs_l2), pch = 20, add = TRUE)
@

\vfill


\section*{Systematic Sample of Parallel Transects}

<<sys>>=
par(mfrow = c(2, 2), mar = c(1, 1, 2, 1), cex = 1)

sys_s1 <- sys(sim_R, 25)
plot(sim_R,
     main = paste('Systematic Sample, length =',
                  round(sum(lengths.psp(sys_s1)))))
plot(sys_s1, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, sys_s1), pch = 20, add = TRUE)

sys_l1 <- sys(sim_R, 50)
plot(sim_R,
     main = paste('Systematic Sample, length =',
                  round(sum(lengths.psp(sys_l1)))))
plot(sys_l1, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, sys_l1), pch = 20, add = TRUE)

sys_s2 <- sys(sim_R, 25)
plot(sim_R,
     main = paste('Systematic Sample, length =',
                  round(sum(lengths.psp(sys_s2)))))
plot(sys_s2, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, sys_s2), pch = 20, add = TRUE)

sys_l2 <- sys(sim_R, 50)
plot(sim_R,
     main = paste('Systematic Sample, length =',
                  round(sum(lengths.psp(sys_l2)))))
plot(sys_l2, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, sys_l2), pch = 20, add = TRUE)
@

\pagebreak


\section*{Inhibitory Plus Close Pairs of Parallel Transects}

<<inhib>>=
par(mfrow = c(2, 2), mar = c(1, 1, 2, 1), cex = 1)

inh_s1 <- inhib(sim_R, 22, 3, 60)
plot(sim_R,
     main = paste('Inhibitory Plus Pairs, length =',
                  round(sum(lengths.psp(inh_s1)))))
plot(inh_s1, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, inh_s1), pch = 20, add = TRUE)

inh_l1 <- inhib(sim_R, 44, 6, 30)
plot(sim_R,
     main = paste('Inhibitory Plus Pairs, length =',
                  round(sum(lengths.psp(inh_l1)))))
plot(inh_l1, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, inh_l1), pch = 20, add = TRUE)

inh_s2 <- inhib(sim_R, 22, 3, 60)
plot(sim_R,
     main = paste('Inhibitory Plus Pairs, length =',
                  round(sum(lengths.psp(inh_s2)))))
plot(inh_s2, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, inh_s2), pch = 20, add = TRUE)

inh_l2 <- inhib(sim_R, 44, 6, 30)
plot(sim_R,
     main = paste('Inhibitory Plus Pairs, length =',
                  round(sum(lengths.psp(inh_l2)))))
plot(inh_l2, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, inh_l2), pch = 20, add = TRUE)
@

\vfill


\section*{Latin Hypercube Sampling-Traveling Salesperson}

<<lhstsp>>=
par(mfrow = c(2, 2), mar = c(1, 1, 2, 1), cex = 1)

lhstsp_s1 <- lhstsp(sim_R, 300)
plot(sim_R,
     main = paste('LHS-TSP, length =',
                  round(sum(lengths.psp(lhstsp_s1)))))
plot(lhstsp_s1, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, lhstsp_s1), pch = 20, add = TRUE)

lhstsp_l1 <- lhstsp(sim_R, 1200)
plot(sim_R,
     main = paste('LHS-TSP, length =',
                  round(sum(lengths.psp(lhstsp_l1)))))
plot(lhstsp_l1, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, lhstsp_l1), pch = 20, add = TRUE)

lhstsp_s2 <- lhstsp(sim_R, 300)
plot(sim_R,
     main = paste('LHS-TSP, length =',
                  round(sum(lengths.psp(lhstsp_s2)))))
plot(lhstsp_s2, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, lhstsp_s2), pch = 20, add = TRUE)

lhstsp_l2 <- lhstsp(sim_R, 1200)
plot(sim_R,
     main = paste('LHS-TSP, length =',
                  round(sum(lengths.psp(lhstsp_l2)))))
plot(lhstsp_l2, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, lhstsp_l2), pch = 20, add = TRUE)
@

\pagebreak


\section*{Hilbert Curve}

<<hilbert>>=
par(mfrow = c(2, 2), mar = c(1, 1, 2, 1), cex = 1)

hilbert_s1 <- hilbert(sim_R, 4)
plot(sim_R,
     main = paste('Hilbert Curve, length =',
                  round(sum(lengths.psp(hilbert_s1)))))
plot(hilbert_s1, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, hilbert_s1), pch = 20, add = TRUE)

hilbert_l1 <- hilbert(sim_R, 5)
plot(sim_R,
     main = paste('Hilbert Curve, length =',
                  round(sum(lengths.psp(hilbert_l1)))))
plot(hilbert_l1, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, hilbert_l1), pch = 20, add = TRUE)

hilbert_s2 <- hilbert(sim_R, 4)
plot(sim_R,
     main = paste('Hilbert Curve, length =',
                  round(sum(lengths.psp(hilbert_s2)))))
plot(hilbert_s2, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, hilbert_s2), pch = 20, add = TRUE)

hilbert_l2 <- hilbert(sim_R, 5)
plot(sim_R,
     main = paste('Hilbert Curve, length =',
                  round(sum(lengths.psp(hilbert_l2)))))
plot(hilbert_l2, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, hilbert_l2), pch = 20, add = TRUE)
@

\vfill


\section*{Particle Movement}

<<rpm>>=
par(mfrow = c(2, 2), mar = c(1, 1, 2, 1), cex = 1)

rpm_s1 <- rpm(sim_R, 17000)
plot(sim_R,
     main = paste('Random Particle Movement, length =',
                  round(sum(lengths.psp(rpm_s1)))))
plot(rpm_s1, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, rpm_s1), pch = 20, add = TRUE)

rpm_l1 <- rpm(sim_R, 34500)
plot(sim_R,
     main = paste('Random Particle Movement, length =',
                  round(sum(lengths.psp(rpm_l1)))))
plot(rpm_l1, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, rpm_l1), pch = 20, add = TRUE)

rpm_s2 <- rpm(sim_R, 17000)
plot(sim_R,
     main = paste('Random Particle Movement, length =',
                  round(sum(lengths.psp(rpm_s2)))))
plot(rpm_s2, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, rpm_s2), pch = 20, add = TRUE)

rpm_l2 <- rpm(sim_R, 34500)
plot(sim_R,
     main = paste('Random Particle Movement, length =',
                  round(sum(lengths.psp(rpm_l2)))))
plot(rpm_l2, col = 'grey', add = TRUE)
plot(sample_ppp(sim_dataset, rpm_l2), pch = 20, add = TRUE)
@


\end{document}

% vim: foldmethod=marker:
